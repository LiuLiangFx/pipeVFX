#!/usr/bin/python2
# =================================================================================
#    This file is part of pipeVFX.
#
#    pipeVFX is a software system initally authored back in 2006 and currently
#    developed by Roberto Hradec - https://bitbucket.org/robertohradec/pipevfx
#
#    pipeVFX is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Lesser General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    pipeVFX is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public License
#    along with pipeVFX.  If not, see <http://www.gnu.org/licenses/>.
# =================================================================================

import sys, os, traceback
sys.path.insert( 0, os.path.abspath('../tools/python/') )

# build all pkgs, if not already built!
import build
print 'build.installRoot() =', build.installRoot()

# pkgs will have all scons builds as its parameters
# to use boost, just add pkgs.boost as a dependency
pkgs = build.pkgs.all(ARGUMENTS) # noqa


# get installed app versions using pipe
import pipe

# we need libraries for pipe to work, so if we don't have then yet,
# we cant build cortex now!
canBuildCortexNow = False
try:
    pipe.apps.maya()
    canBuildCortexNow = True
except:
    print '''

    It seems we don't have libraries built yet, so we can't build app dependent pkgs yet! (ex: cortex,alembic)
    Run scons install again after this build finishes to complete the build!

    '''
    traceback.print_exc()


if canBuildCortexNow:
    nuke    = pipe.apps.nuke()
    maya    = pipe.apps.maya()
    prman   = pipe.apps.prman()
    houdini = pipe.apps.houdini()

    # grab version lists
    mv = build.pkgs.versionSort( maya.versionList() )
    pv = build.pkgs.versionSort( prman.versionList() )
    nv = build.pkgs.versionSort( nuke.versionList() )
    hv = build.pkgs.versionSort( houdini.versionList() )

    # disable arnold!
    pipe.version.set(arnold='0.0.0')


    # build alembic for each version of maya and prman, so we get the plugins!
    alembic = []
    ppv = [ v for v in pv if float(v.split('.')[0]) < 21 ]
    #pv = [ v for v in pv if float(v.split('.')[0]) < 21 ]
    for n in range(2):
        pipe.version.set( maya  = mv[0] if len(mv)<=n else mv[n] )
        pipe.version.set( prman = ppv[0] if len(ppv)<=n else ppv[n] )

        alembic.append( build.alembic(
            ARGUMENTS,
            'alembic',
            targetSuffix = "maya%sprman%s" % (pipe.version.get('maya'),pipe.version.get('prman')),
            download=[(
            #     'https://github.com/alembic/alembic/archive/1.6.1.tar.gz',
            #     'alembic-1.6.1.tar.gz',
            #     '1.6.1',
            #     'e1f9f2cbe1899d3d55b58708b9307482',
            #     {ilmbase: "2.2.0", openexr: "2.2.0"},
            # ),(
                'https://github.com/alembic/alembic/archive/1.5.8.tar.gz',
                'alembic-1.5.8.tar.gz',
                '1.5.8',
                'a70ba5f2e80b47d346d15d797c28731a',
                {pkgs.ilmbase: "2.2.0", pkgs.openexr: "2.2.0", pkgs.gcc: '4.1.2'},
            )],
            baseLibs=[pkgs.python],
            depend=[pkgs.hdf5,pkgs.python,pkgs.yasm,pkgs.boost],
            apps = [
                ( pipe.apps.maya, pipe.version.get('maya')),
                ( pipe.apps.prman, pipe.version.get('prman')),
            ]
        ))
    pkgs.alembic = alembic[-1]

    # cortex versions to build
    boostVersion = "1.51.0"
    download = [
        [
            'https://github.com/ImageEngine/cortex/archive/9.13.2.tar.gz',
            'cortex-9.13.2.tar.gz',
            '9.13.2',
            'a9f5ac8f19958a8d636d7706a5ca6be0',
            {pkgs.boost : boostVersion, pkgs.alembic : "1.5.8", pkgs.gcc : '4.1.2'}
        ]
    ]

    # cortex dependency
    depend = [
        pkgs.icu, pkgs.scons, pkgs.tbb,
        pkgs.freeglut, pkgs.freetype, pkgs.libpng, pkgs.hdf5,
        pkgs.tiff, pkgs.jpeg, pkgs.alembic, pkgs.openssl,
        pkgs.ilmbase, pkgs.openexr
    ]

    # build cortex
    cortex = {}
    # build one version of IECore, IECorePython and IECoreGL libraries for each boost version
    for bv in pkgs.boost.versions:
        if bv in ['1.51.0','1.55.0','1.56.0']:
            # build cortex core libraries only
            sufix = "core.boost.%s" % bv
            cortex[sufix] = build.cortex(
                ARGUMENTS, # noqa
                'cortex',
                targetSuffix = sufix,
                download = build.cortex.pkg(download, pkgs.boost, bv),
                baseLibs = [pkgs.python],
                depend = depend,
                sconsInstall = "installCore installGL"
            )

    # now build IECoreAlembic for all versions of alembic
    for v in pkgs.alembic.versions:
        sufix = "core.alembic.%s" % v
        cortex[sufix] = build.cortex(
            ARGUMENTS, # noqa
            'cortex',
            targetSuffix = sufix,
            download = build.cortex.pkg(download, pkgs.alembic, v),
            sed = build.cortex.noIECoreSED(),
            baseLibs = [pkgs.python],
            depend = depend,
            sconsInstall = "installAlembic"
        )

    class cortexApps:
        ''' # this class stores data to build cortex for all the apps.'''
        name, versions, baseLibs, install, download = (0,1,2,3,4)
        def __init__(self, download):
            # disable alembic from now on...
            pkg = build.cortex.pkg
            noAlembic = pkg(download, pkgs.alembic, None)
            self.builds = [
                # IECoreRI needs to be build first since IECoreMaya depends on it!
                ('prman',   pv[:2], pkgs.python, 'installRI',   noAlembic),
                ('maya',    mv    , None,        'installMaya', noAlembic),
                ('nuke',    nv[:2], None,        'installNuke', noAlembic),
                ('houdini', hv[:2], None,        'installHoudini installMantra', pkg(pkg(pkg(noAlembic, pkgs.gcc, '4.8.3'), pkgs.boost, '1.55.0'), pkgs.tbb, None) ),
            ]

            # use the data in buildList to build cortex for all apps
            for app in self.builds:
                for v in app[ self.versions ]:
                    sufix = app[ self.name ] + v
                    cortex[sufix] = build.cortex(
                        ARGUMENTS, # noqa
                        'cortex',
                        targetSuffix = sufix,
                        download = app[ self.download ],
                        sed = build.cortex.noIECoreSED(),
                        baseLibs = app[ self.baseLibs ],
                        depend = depend+[pkgs.python],
                        apps = ( app[ self.name ], v ),
                        sconsInstall = app[ self.install ],
                    )
    cortexApps(download)

    # build gaffer
    gaffer = {}
    for prman in pv[:2]:
        sufix = 'prman.'+ prman
        gaffer = build.gaffer(
            ARGUMENTS, # noqa
            'gaffer',
            targetSuffix = "",
            download = [
                [
                #     'https://github.com/ImageEngine/gaffer/archive/0.28.3.0.tar.gz',
                #     'gaffer-0.28.3.0.tar.gz',
                #     '0.28.3.0',
                #     'd20bc719696857cc19b117e538c16cc8',
                #     {pkgs.boost : boostVersion, pkgs.alembic : "1.5.8", pkgs.gcc : '4.1.2'}
                # ],[
                    'https://github.com/GafferHQ/gaffer/archive/0.30.0.0.tar.gz',
                    'gaffer-0.30.0.0.tar.gz',
                    '0.30.0.0',
                    'c02822b86f17de8af08aaabf7e61e1a2',
                    {pkgs.boost : boostVersion, pkgs.alembic : "1.5.8", pkgs.gcc : '4.1.2'}
                ]

            ],
            baseLibs = [pkgs.python],
            depend =  depend + [ cortex['core.boost.%s' % boostVersion], pkgs.qt, pkgs.pyqt, pkgs.osl, pkgs.oiio, pkgs.ocio, pkgs.llvm ],
            apps = ( 'prman', prman ),
            sconsInstall = "install"
        )





    # build openvdb for each version of maya, so we get the plugins!
    pyVersions = pkgs.python.versions.keys()
    pyVersions.sort()
    openvdb = []
    for n in range(2):
        pipe.version.set( maya  = mv[0] if len(mv)<=n else mv[n] )
        mayaPath = pipe.apps.maya().path()

        openvdb.append( build.make(
            ARGUMENTS,
            'openvdb',
            targetSuffix = "maya%s" % (pipe.version.get('maya')),
            download=[(
            #     'https://github.com/dreamworksanimation/openvdb/archive/v4.0.0.tar.gz',
            #     'openvdb-4.0.0.tar.gz',
            #     '4.0.0',
            #     '54068805fb2ebedd3eeee44d7ecd56a2',
            #     {pkgs.ilmbase: "2.2.0", pkgs.openexr: "2.2.0", pkgs.gcc: '4.8.3'},
            # ),(
                'https://github.com/dreamworksanimation/openvdb/archive/v3.2.0.tar.gz',
                'openvdb-3.2.0.tar.gz',
                '3.2.0',
                '54068805fb2ebedd3eeee44d7ecd56a2',
                {pkgs.ilmbase: "2.2.0", pkgs.openexr: "2.2.0", pkgs.gcc: '4.8.3'},
            )],
            sed = {'0.0.0' : {
                # Patch openvdb maya plugin to FIX rendering in the farm, without a DISPLAY being set!
                'openvdb_maya/maya/OpenVDBVisualizeNode.cc' : [
                    # ('namespace mvdb', '#include <maya/MGlobal.h>\n\nnamespace mvdb'),
                    ('view.beginGL()', 'if(MGlobal::mayaState() == MGlobal::kBatch) return;\n\nview.beginGL()'),
                    ('mSurfaceShader.setVertShader', 'if(MGlobal::mayaState() != MGlobal::kBatch) {\n\nmSurfaceShader.setVertShader'),
                    ('mPointShader.build();', 'mPointShader.build();}'),
                    # ('if (!inputVdb) return', 'mBBox = MBoundingBox(MPoint(-2.0, -1.0, -1.0), MPoint(1.0, 1.0, 1.0));if (!inputVdb) return'),
                    ('return MBoundingBox(MPoint(-1.0, -1.0, -1.0), MPoint(1.0, 1.0, 1.0))', 'return mBBox'),
                    ('if (plug == aCachedInternalNodes) {','''
                        if(MGlobal::mayaState() == MGlobal::kBatch) {
                            MPoint pMin, pMax;
                            mBBoxBuffers.clear();
                            mBBoxBuffers.resize(grids.size());

                            for (size_t n = 0, N = grids.size(); n < N; ++n) {
                                mvdb::BoundingBoxGeo drawBBox(mBBoxBuffers[n]);
                                drawBBox(grids[n]);

                                for (int i = 0; i < 3; ++i) {
                                    pMin[i] = drawBBox.min()[i];
                                    pMax[i] = drawBBox.max()[i];
                                }
                            }
                            mBBox = MBoundingBox(pMin, pMax);

                            MDataHandle outHandle = data.outputValue(aCachedBBox);
                            outHandle.set(true);
                        }

                        if (plug == aCachedInternalNodes) {
                    '''),
                ],'openvdb_maya/maya/OpenVDBUtil.cc' : [
                    # ('mProgram(0)', 'if(MGlobal::mayaState() == MGlobal::kBatch) return;mProgram(0)'),
                    ('ShaderProgram() { clear()', 'ShaderProgram() { if(MGlobal::mayaState() != MGlobal::kBatch) clear()'),
                    ('insertFrameNumber','''
                        insertFrameNumberPrman(std::string& str, const MTime& time, int numberingScheme)
                        {
                            size_t pos = str.find_first_of("$F");
                            if (pos != std::string::npos) {

                                size_t length = str.find_last_of(".") - pos;
                                size_t pad = atoi(str.substr(pos+2, length).c_str());

                                // Current frame value
                                double frame = time.as(MTime::uiUnit());

                                // Frames per second
                                const MTime dummy(1.0, MTime::kSeconds);
                                const double fps = dummy.as(MTime::uiUnit());

                                // Ticks per frame
                                const double tpf = 6000.0 / fps;
                                const int tpfDigits = int(std::log10(int(tpf)) + 1);

                                const int wholeFrame = int(frame);
                                std::stringstream ss;
                                ss << std::setw(int(pad)) << std::setfill('0');

                                if (numberingScheme == 1) { // Fractional frame values
                                    ss << wholeFrame;

                                    std::stringstream stream;
                                    stream << frame;
                                    std::string tmpStr = stream.str();;
                                    tmpStr = tmpStr.substr(tmpStr.find('.'));
                                    if (!tmpStr.empty()) ss << tmpStr;

                                } else if (numberingScheme == 2) { // Global ticks
                                    int ticks = int(openvdb::math::Round(frame * tpf));
                                    ss << ticks;
                                } else { // Frame.SubTick
                                    ss << wholeFrame;
                                    const int frameTick = (openvdb::math::Round(frame - double(wholeFrame)) * tpf);
                                    if (frameTick > 0) {
                                        ss << "." << std::setw(tpfDigits) << std::setfill('0') << frameTick;
                                    }
                                }

                                str.replace(pos, length, ss.str());
                            }
                        }
                        void insertFrameNumber
                    '''),
                ],'openvdb_maya/maya/OpenVDBUtil.h' : [
                    ('<maya/MTime.h>', '<maya/MTime.h>\n#include <maya/MGlobal.h>'),
                    ('mBuffer->genVertexBuffer(points)', 'if(MGlobal::mayaState() != MGlobal::kBatch) mBuffer->genVertexBuffer(points)'),
                    ('mBuffer->genIndexBuffer(indices, GL_LINES)', 'if(MGlobal::mayaState() != MGlobal::kBatch) mBuffer->genIndexBuffer(indices, GL_LINES)'),
                    ('insertFrameNumber',''' insertFrameNumberPrman(std::string& str, const MTime& time, int numberingScheme = 0); \nvoid\ninsertFrameNumber'''),
                ],'openvdb_maya/maya/OpenVDBReadNode.cc' : [
                    ('insertFrameNumber','insertFrameNumberPrman'),
                ],

            }#,'4.0.0' : {
            },
            # baseLibs=[pkgs.python],
            depend=[ pkgs.hdf5, pkgs.boost, pkgs.glfw, pkgs.log4cplus, pkgs.numpy ],
            cmd = [
                'export PYTHON_VERSION="%s"' % pyVersions[-1],
                'export PYTHON_VERSION_MAJOR="%s"' % '.'.join(pyVersions[-1].split('.')[:2]),
                'cd openvdb',
                'if [ ! -e $TARGET_FOLDER/lib/libopenvdb.so ] ; then make -j $DCORES lib install has_python=no '
                    'DESTDIR=$TARGET_FOLDER '
                    'PYTHON_INCL_DIR=$PYTHON_TARGET_FOLDER/include/python$PYTHON_VERSION_MAJOR/ '
                    'PYTHON_LIB_DIR=$PYTHON_TARGET_FOLDER/lib/ '
                    'BOOST_INCL_DIR=$BOOST_TARGET_FOLDER/include '
                    'BOOST_LIB_DIR=$BOOST_TARGET_FOLDER/lib/python$PYTHON_VERSION_MAJOR/ '
                    'ILMBASE_INCL_DIR=$ILMBASE_TARGET_FOLDER/include '
                    'ILMBASE_LIB_DIR=$ILMBASE_TARGET_FOLDER/lib '
                    'EXR_INCL_DIR=$EXR_TARGET_FOLDER/include '
                    'EXR_LIB_DIR=$EXR_TARGET_FOLDER/lib '
                    'TBB_INCL_DIR=$TBB_TARGET_FOLDER/include '
                    'TBB_LIB_DIR=$TBB_TARGET_FOLDER/lib '
                    'LOG4CPLUS_INCL_DIR=$LOG4CPLUS_TARGET_FOLDER/include '
                    'LOG4CPLUS_LIB_DIR=$LOG4CPLUS_TARGET_FOLDER/lib '
                    'LOG4CPLUS_LIB=" -Wl,-rpath,$LOG4CPLUS_TARGET_FOLDER/lib -llog4cplus " '
                    'BLOSC_INCL_DIR=/usr/include '
                    'BLOSC_LIB_DIR=/usr/lib '
                ';fi',
                'cd ../openvdb_maya && make -j $DCORES install '
                    'DESTDIR=$TARGET_FOLDER '
                    'OPENVDB_INCL_DIR=$TARGET_FOLDER/include '
                    'OPENVDB_LIB_DIR=$TARGET_FOLDER/lib '
                    'OPENVDB_LIB="-Wl,-rpath,$TARGET_FOLDER/lib/ -lopenvdb" '
                    'PYTHON_INCL_DIR=$PYTHON_TARGET_FOLDER/include/python$PYTHON_VERSION_MAJOR/ '
                    'PYTHON_LIB_DIR=$PYTHON_TARGET_FOLDER/lib/ '
                    'BOOST_INCL_DIR=$BOOST_TARGET_FOLDER/include '
                    'BOOST_LIB_DIR=$BOOST_TARGET_FOLDER/lib/python$PYTHON_VERSION_MAJOR/ '
                    'ILMBASE_INCL_DIR=$ILMBASE_TARGET_FOLDER/include '
                    'ILMBASE_LIB_DIR=$ILMBASE_TARGET_FOLDER/lib '
                    'EXR_INCL_DIR=$EXR_TARGET_FOLDER/include '
                    'EXR_LIB_DIR=$EXR_TARGET_FOLDER/lib '
                    'TBB_INCL_DIR=$TBB_TARGET_FOLDER/include '
                    'TBB_LIB_DIR=$TBB_TARGET_FOLDER/lib '
                    'LOG4CPLUS_INCL_DIR=$LOG4CPLUS_TARGET_FOLDER/include '
                    'LOG4CPLUS_LIB_DIR=$LOG4CPLUS_TARGET_FOLDER/lib '
                    'BLOSC_INCL_DIR=/usr/include '
                    'BLOSC_LIB_DIR=/usr/lib '
                    'MAYA_DESTDIR=$TARGET_FOLDER/maya/%s/ '
                    'MAYA_LOCATION=%s ' % (pipe.version.get('maya'), mayaPath),
            ],
            src = 'README.md'
        ))
    pkgs.openvdb = openvdb[-1]
