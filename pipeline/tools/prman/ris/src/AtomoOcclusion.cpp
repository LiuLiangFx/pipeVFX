/*  $Date: 2015/07/06 $  $Revision: #2 $
# ------------------------------------------------------------------------------
#
# Copyright (c) 2014 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/
#include "RixBxdf.h"
#include "RixShadingUtils.h"
#include "PxrSurfaceOpacity.h"
#include <cstring> // memset

static const RtFloat k_minfacing = .0001f; // NdV < k_minfacing is invalid

static const unsigned char k_reflDiffuseLobeId = 0;
static const unsigned char k_tranDiffuseLobeId = 0;
static const unsigned char k_albedoLobeId = 0;

static RixBXLobeSampled s_reflDiffuseLobe;
static RixBXLobeSampled s_tranDiffuseLobe;
static RixBXLobeSampled s_albedoLobe;

static RixBXLobeTraits s_reflDiffuseLobeTraits;
static RixBXLobeTraits s_tranDiffuseLobeTraits;
static RixBXLobeTraits s_albedoLobeTraits;

class AtomoOcclusion : public RixBsdf
{
public:

    AtomoOcclusion(RixShadingContext const *sc, RixBxdfFactory *bx,
               RixBXLobeTraits const &lobesWanted,
               RtColorRGB const *diff,
               RtColorRGB const *trans,
               RtNormal3 const *bumpNormal) :
        RixBsdf(sc, bx),
        m_lobesWanted(lobesWanted),
        m_diffuse(diff),
        m_transmission(trans),
        m_bumpNormal(bumpNormal)
    {
        RixBXLobeTraits lobes = s_reflDiffuseLobeTraits | s_albedoLobeTraits;
        if (m_transmission)
            lobes |= s_tranDiffuseLobeTraits;

        m_lobesWanted &= lobes;

        sc->GetBuiltinVar(RixShadingContext::k_P, &m_P);
        if(m_bumpNormal)
            m_Nn = bumpNormal;
        else
            sc->GetBuiltinVar(RixShadingContext::k_Nn, &m_Nn);
        sc->GetBuiltinVar(RixShadingContext::k_Ngn, &m_Ngn);
        sc->GetBuiltinVar(RixShadingContext::k_Tn, &m_Tn);
        sc->GetBuiltinVar(RixShadingContext::k_Vn, &m_Vn);
    }

    virtual RixBXEvaluateDomain GetEvaluateDomain()
    {
        if(m_transmission)
            return k_RixBXBoth;
        else
            return k_RixBXFront;  // two-sided, but opaque
    }
    virtual void GetAggregateLobeTraits(RixBXLobeTraits *t)
    {
        *t = m_lobesWanted;
    }

    virtual void GenerateSample(RixBXTransportTrait transportTrait,
                                RixBXLobeTraits const *lobesWanted,
                                RixRNG *rng,
                                RixBXLobeSampled *lobeSampled,
                                RtVector3   *Ln,
                                RixBXLobeWeights &W,
                                RtFloat *FPdf, RtFloat *RPdf)
    {
        RtInt nPts = shadingCtx->numPts;
        RixBXLobeTraits all = GetAllLobeTraits();
        RtFloat2 *xi = (RtFloat2 *) RixAlloca(sizeof(RtFloat2) * nPts);
        rng->DrawSamples2D(nPts,xi);

        RtColorRGB *reflDiffuseWgt = NULL;
        RtColorRGB *tranDiffuseWgt = NULL;
        RtColorRGB *albedoWgt = NULL;

        if(!m_transmission)
        {
            RtNormal3 Nf;
            for(int i = 0; i < nPts; i++)
            {
                lobeSampled[i].SetValid(false);

                RixBXLobeTraits lobes = (all & lobesWanted[i]);
                bool doDiff = (lobes & s_reflDiffuseLobeTraits).HasAny();
                bool doAlbedo = (lobes & s_albedoLobeTraits).HasAny();

                if (!reflDiffuseWgt && doDiff)
                    reflDiffuseWgt = W.AddActiveLobe(s_reflDiffuseLobe);
                if (!albedoWgt && doAlbedo)
                    albedoWgt = W.AddActiveLobe(s_albedoLobe);

                if (doAlbedo)
                    albedoWgt[i] = m_diffuse[i];
                if (doDiff)
                {
                    // we generate samples on the (front) side of Vn since
                    // we have no translucence effects.
                    RtFloat NdV;
                    if(m_bumpNormal)
                        NdV = m_Ngn[i].Dot(m_Vn[i]);
                    else
                        NdV = m_Nn[i].Dot(m_Vn[i]);
                    if(NdV >= 0.f)
                        Nf = m_Nn[i];
                    else
                    {
                        Nf = -m_Nn[i];
                        NdV = -NdV;
                    }
                    if(NdV > k_minfacing)
                    {
                        if(m_bumpNormal)
                            NdV = AbsDot(Nf, m_Vn[i]); // may be negative
                        generate(NdV, Nf, m_Tn[i], m_diffuse[i], xi[i],
                                 Ln[i], reflDiffuseWgt[i], FPdf[i], RPdf[i]);
                        lobeSampled[i] = s_reflDiffuseLobe;
                    }
                    // else invalid.. NullTrait
                }
            }
        }
        else
        {
            // generate samples on both sides of the surface in
            // proportion to the ratio between diffuse and transmission
            for(int i=0; i<nPts; ++i)
            {
                lobeSampled[i].SetValid(false);

                RixBXLobeTraits lobes = (all & lobesWanted[i]);
                bool doDiff = (lobes & s_reflDiffuseLobeTraits).HasAny();
                bool doTrans = (lobes & s_tranDiffuseLobeTraits).HasAny();
                bool doAlbedo = (lobes & s_albedoLobeTraits).HasAny();

                if (!reflDiffuseWgt && doDiff)
                    reflDiffuseWgt = W.AddActiveLobe(s_reflDiffuseLobe);
                if (!tranDiffuseWgt && doTrans)
                    tranDiffuseWgt = W.AddActiveLobe(s_tranDiffuseLobe);
                if (!albedoWgt && doAlbedo)
                    albedoWgt = W.AddActiveLobe(s_albedoLobe);

                float refl = doDiff ? m_diffuse[i].Luminance() : 0.f;
                float trans = doTrans ? m_transmission[i].Luminance() : 0.f;
                float total = refl + trans;
                if (doAlbedo)
                    albedoWgt[i] = m_diffuse[i];
                if(total > 0.f)
                {
                    RtNormal3 Nf;
                    refl /= total;
                    trans /= total;
                    RtFloat NdV;
                    if(m_bumpNormal)
                        NdV = m_Ngn[i].Dot(m_Vn[i]); // bump insurance
                    else
                        NdV = m_Nn[i].Dot(m_Vn[i]);
                    if(NdV >= 0.0f)
                        Nf = m_Nn[i];
                    else
                    {
                        Nf = -m_Nn[i];
                        NdV = -NdV;
                    }
                    if(NdV > k_minfacing)
                    {
                        if(m_bumpNormal)
                            NdV = AbsDot(Nf, m_Vn[i]); // can be negative
                        int lobe = RixChooseAndRemap(xi[i].y, 1, &refl);
                        if(lobe == 0)
                        {
                            generate(NdV, Nf, m_Tn[i], m_diffuse[i], xi[i],
                                     Ln[i], reflDiffuseWgt[i],
                                     FPdf[i], RPdf[i]);
                            lobeSampled[i] = s_reflDiffuseLobe;
                            FPdf[i] *= refl;
                            RPdf[i] *= refl;
                        }
                        else
                        {
                            if (doAlbedo)
                                albedoWgt[i] = m_transmission[i]; // override
                            generate(NdV,  // NdV == -N dot -V
                                    -Nf, m_Tn[i], m_transmission[i], xi[i],
                                     Ln[i], tranDiffuseWgt[i],
                                     FPdf[i], RPdf[i]);
                            lobeSampled[i] = s_tranDiffuseLobe;
                            FPdf[i] *= trans;
                            RPdf[i] *= trans;
                        }
                    }
                }
                // else invalid, null trait
            }
        }
    }

    virtual void EvaluateSample(RixBXTransportTrait transportTrait,
                                RixBXLobeTraits const *lobesWanted,
                                RixBXLobeTraits *lobesEvaluated,
                                RtVector3 const *Ln, RixBXLobeWeights &W,
                                RtFloat *FPdf, RtFloat *RPdf)
    {
        RtNormal3 Nf;
        RtInt nPts = shadingCtx->numPts;
        RixBXLobeTraits all = GetAllLobeTraits();

        RtColorRGB *reflDiffuseWgt = NULL;
        RtColorRGB *tranDiffuseWgt = NULL;
        RtColorRGB *albedoWgt = NULL;

        RixDisplayServices *dspySvc = shadingCtx->GetDisplayServices();

        if(!m_transmission)
        {
            for(int i = 0; i < nPts; i++)
            {
                lobesEvaluated[i].SetNone();
                RixBXLobeTraits lobes = (all & lobesWanted[i]);
                bool doDiff = (lobes & s_reflDiffuseLobeTraits).HasAny();
                bool doAlbedo = (lobes & s_albedoLobeTraits).HasAny();

                if (!reflDiffuseWgt && doDiff)
                    reflDiffuseWgt = W.AddActiveLobe(s_reflDiffuseLobe);
                if (!albedoWgt && doAlbedo)
                    albedoWgt = W.AddActiveLobe(s_albedoLobe);

                if (doAlbedo)
                {
                    albedoWgt[i] = m_diffuse[i];
                    lobesEvaluated[i] |= s_albedoLobeTraits;
                }
                if (doDiff)
                {
                    RtFloat NdV;
                    if(m_bumpNormal)
                        NdV = m_Ngn[i].Dot(m_Vn[i]); // bump insurance
                    else
                        NdV = m_Nn[i].Dot(m_Vn[i]);
                    if(NdV >= 0.f)
                        Nf = m_Nn[i];
                    else
                    {
                        Nf = -m_Nn[i];
                        NdV = -NdV;
                    }
                    if(NdV > k_minfacing)
                    {
                        if(m_bumpNormal)
                            NdV = AbsDot(Nf, m_Vn[i]); // can be negative
                        RtFloat NdL = Nf.Dot(Ln[i]);
                        if(NdL > 0.f)
                        {
                            evaluate(NdV, NdL, m_diffuse[i],
                                     reflDiffuseWgt[i], FPdf[i], RPdf[i]);
                            lobesEvaluated[i] |= s_reflDiffuseLobeTraits;
                        }
                    }
                }
            }
        }
        else
        {
            // thin translucent case
            for(int i = 0; i < nPts; i++)
            {
                lobesEvaluated[i].SetNone();
                RixBXLobeTraits lobes = (all & lobesWanted[i]);
                bool doDiff = (lobes & s_reflDiffuseLobeTraits).HasAny();
                bool doTrans = (lobes & s_tranDiffuseLobeTraits).HasAny();
                bool doAlbedo = (lobes & s_albedoLobeTraits).HasAny();

                if (!reflDiffuseWgt && doDiff)
                    reflDiffuseWgt = W.AddActiveLobe(s_reflDiffuseLobe);
                if (!tranDiffuseWgt && doTrans)
                    tranDiffuseWgt = W.AddActiveLobe(s_tranDiffuseLobe);
                if (!albedoWgt && doAlbedo)
                    albedoWgt = W.AddActiveLobe(s_albedoLobe);

                float refl = doDiff ? m_diffuse[i].Luminance() : 0.f;
                float trans = doTrans ? m_transmission[i].Luminance() : 0.f;
                float total = refl + trans;
                if (doAlbedo)
                {
                    albedoWgt[i] = m_diffuse[i];
                    lobesEvaluated[i] |= s_albedoLobeTraits;
                }
                if(total > 0.f)
                {
                    refl /= total;
                    trans /= total;
                    RtFloat NdV = m_Ngn[i].Dot(m_Vn[i]); // bump insurance
                    if(NdV >= 0.f)
                        Nf = m_Nn[i];
                    else
                    {
                        Nf = -m_Nn[i];
                        NdV = -NdV;
                    }
                    if(NdV > k_minfacing)
                    {
                        RtFloat NdL = Nf.Dot(Ln[i]);
                        if(m_bumpNormal)
                            NdV = AbsDot(Nf, m_Vn[i]);
                        if(NdL >= 0.f)
                        {
                            // if L is on front side, evaluate it through refl
                            evaluate(NdV, NdL, m_diffuse[i],
                                     reflDiffuseWgt[i], FPdf[i], RPdf[i]);
                            lobesEvaluated[i] |= s_reflDiffuseLobeTraits;
                            FPdf[i] *= refl;
                            RPdf[i] *= refl;
                        }
                        else
                        {
                            // else evaluate it through trans
                            if (doAlbedo)
                                albedoWgt[i] = m_transmission[i]; // override
                            evaluate(NdV, -NdL, m_transmission[i],
                                     tranDiffuseWgt[i], FPdf[i], RPdf[i]);
                            lobesEvaluated[i] |= s_tranDiffuseLobeTraits;
                            FPdf[i] *= trans;
                            RPdf[i] *= trans;
                        }
                    }
                }
            }
        }
    }

    virtual void EvaluateSamplesAtIndex(RixBXTransportTrait transportTrait,
                                        RixBXLobeTraits const &lobesWanted,
                                        RtInt index, RtInt nsamps,
                                        RixBXLobeTraits *lobesEvaluated,
                                        RtVector3 const *Ln,
                                        RixBXLobeWeights &W,
                                        RtFloat *FPdf, RtFloat *RPdf)
    {
        for (int i = 0; i < nsamps; i++)
            lobesEvaluated[i].SetNone();

        RixBXLobeTraits lobes = lobesWanted & GetAllLobeTraits();
        bool doDiff = (lobes & s_reflDiffuseLobeTraits).HasAny();
        bool doTrans = m_transmission && (lobes & s_tranDiffuseLobeTraits).HasAny();
        bool doAlbedo = (lobes & s_albedoLobeTraits).HasAny();

        RtColorRGB *albedoWgt = NULL;
        if (doAlbedo)
        {
            albedoWgt = W.AddActiveLobe(s_albedoLobe);
            for(int i = 0; i < nsamps; i++)
            {
                albedoWgt[i] = m_diffuse[index];
                lobesEvaluated[i] |= s_albedoLobeTraits;
            }
        }

        if(!doDiff && !doTrans)
            return;

        RtNormal3 const &Nn = m_Nn[index];
        RtNormal3 const &Ngn = m_Ngn[index];
        RtVector3 const &Vn = m_Vn[index];
        RtColorRGB const &diff = m_diffuse[index];

        // Make any lobes that we may evaluate or write to active lobes,
        // initialize their lobe weights to zero and fetch a pointer to the
        // lobe weight arrays.

        RtColorRGB *reflDiffuseWgt = doDiff
            ? W.AddActiveLobe(s_reflDiffuseLobe) : NULL;
        RtColorRGB *tranDiffuseWgt = doTrans
            ? W.AddActiveLobe(s_tranDiffuseLobe) : NULL;

        RtNormal3 Nf;
        RtFloat NdV;
        if(m_bumpNormal)
            NdV = Ngn.Dot(Vn); // bump insurance
        else
            NdV = Nn.Dot(Vn);
        if(NdV >= .0f)
            Nf = Nn;
        else
        {
            Nf = -Nn;
            NdV = -NdV;
        }
        RtFloat NfdV;
        if(m_bumpNormal)
            NfdV = AbsDot(Nf, Vn); // bump insurance
        else
            NfdV = NdV;

        if(!doTrans)
        {
            if(NdV > k_minfacing)
            {
                for(int i=0; i<nsamps; ++i)
                {
                    RtFloat NdL = Nf.Dot(Ln[i]);
                    if(NdL > 0.f)
                    {
                        evaluate(NfdV, NdL, diff,
                                 reflDiffuseWgt[i], FPdf[i], RPdf[i]);
                        lobesEvaluated[i] |= s_reflDiffuseLobeTraits;
                    }
                }
            }
        }
        else
        {
            float refl = doDiff ? m_diffuse[index].Luminance() : 0.f;
            float trans = doTrans ? m_transmission[index].Luminance() : 0.f;
            float total = refl + trans;
            if(total > 0.f)
            {
                refl /= total;
                trans /= total;
                if(NdV > k_minfacing)
                {
                    const RtColorRGB &transmission = m_transmission[index];
                    for(int i=0;i<nsamps;++i)
                    {
                        RtFloat NdL = Ngn.Dot(Ln[i]); // bump insurance
                        if(NdL > 0.f)
                        {
                            // if L is on front side, evaluate it through refl
                            NdL = Dot(Nf, Ln[i]); // bump insurance
                            if(NdL > 0.f)
                            {
                                evaluate(NfdV, NdL, diff,
                                         reflDiffuseWgt[i], FPdf[i], RPdf[i]);
                                lobesEvaluated[i] |= s_reflDiffuseLobeTraits;
                                FPdf[i] *= refl;
                                RPdf[i] *= refl;
                            }
                        }
                        else
                        {
                            // else evaluate it through trans
                            NdL = Dot(Nf, Ln[i]); // bump insurance
                            if(NdL < 0.f)
                            {
                                if (doAlbedo)
                                    albedoWgt[i] = m_transmission[index]; // override
                                evaluate(NfdV, -NdL, transmission,
                                     tranDiffuseWgt[i], FPdf[i], RPdf[i]);
                                lobesEvaluated[i] |= s_tranDiffuseLobeTraits;
                                FPdf[i] *= trans;
                                RPdf[i] *= trans;
                            }
                        }
                    }
                }
            }
        }
    }

private:
    PRMAN_INLINE
    void generate(RtFloat NdV,
                 const RtNormal3 &Nn, const RtVector3 &Tn,
                 const RtColorRGB &diff,
                 const RtFloat2 &xi,
                 RtVector3 &Ln, RtColorRGB  &W,
                 RtFloat &FPdf, RtFloat &RPdf)
    {
        RtVector3 TX, TY;
        RixComputeShadingBasis(Nn, Tn, TX, TY);
        RtFloat NdL;
        RixCosDirectionalDistribution(xi, Nn, TX, TY, Ln, NdL);
        W = diff * NdL * F_INVPI;
        FPdf = NdL * F_INVPI;
        RPdf = NdV * F_INVPI;
        assert(FPdf >= 0.f && RPdf >= 0.f);
    }

    PRMAN_INLINE
    void evaluate(RtFloat NdV, RtFloat NdL, const RtColorRGB &diff,
                 RtColorRGB  &W, RtFloat &FPdf, RtFloat &RPdf)
    {
        FPdf = NdL * F_INVPI;
        RPdf = NdV * F_INVPI;
        W = diff * FPdf;
        assert(FPdf >= 0.f && RPdf >= 0.f);
    }

private:
    RixBXLobeTraits m_lobesWanted;
    RtColorRGB const *m_diffuse;
    RtColorRGB const *m_transmission;
    RtFloat const *m_presence;
    RtPoint3 const* m_P;
    RtVector3 const* m_Vn;
    RtVector3 const* m_Tn;
    RtNormal3 const* m_Nn;
    RtNormal3 const* m_Ngn;
    RtNormal3 const* m_bumpNormal;
};

// AtomoOcclusionFactory Implementation
class AtomoOcclusionFactory : public RixBxdfFactory
{
public:
    enum TransmissionBehavior
    {
        k_ignoreTransmission=0,
        k_transmissiveShadows,
        k_transmissiveScatter,
        k_transmissiveScatterAndShadows,
        k_numbehaviors
    };

    AtomoOcclusionFactory();
    ~AtomoOcclusionFactory();

    virtual int Init(RixContext &, char const *pluginpath);
    RixSCParamInfo const *GetParamTable();
    virtual void Finalize(RixContext &);

    virtual void Synchronize(RixContext &ctx, RixSCSyncMsg syncMsg,
                             RixParameterList const *parameterList);

    virtual int CreateInstanceData(RixContext &,
                                   char const *handle,
                                   RixParameterList const *,
                                   InstanceData *id);

    virtual int GetInstanceHints(RtConstPointer instanceData) const;

    virtual RixBsdf *BeginScatter(RixShadingContext const *,
                                  RixBXLobeTraits const &lobesWanted,
                                  RixSCShadingMode sm,
                                  RtConstPointer instanceData);
    virtual void EndScatter(RixBsdf *);

    virtual RixOpacity *BeginOpacity(RixShadingContext const *,
                                     RixSCShadingMode,
                                     RtConstPointer instancedata);
    virtual void EndOpacity(RixOpacity *);

  private:
    // these hold the default (def) values
    RtColorRGB m_diffuseColorDflt;
    RtColorRGB m_transmissionColorDflt;
    RtInt m_transmissionBehaviorDflt;
    RtFloat m_presenceDflt;
};

extern "C" PRMANEXPORT RixBxdfFactory *CreateRixBxdfFactory(const char *hint)
{
    return new AtomoOcclusionFactory();
}

extern "C" PRMANEXPORT void DestroyRixBxdfFactory(RixBxdfFactory *bxdf)
{
    delete (AtomoOcclusionFactory *) bxdf;
}

/*-----------------------------------------------------------------------*/
AtomoOcclusionFactory::AtomoOcclusionFactory()
{
    m_diffuseColorDflt = RtColorRGB(.5f);
    m_presenceDflt = 1.f;
    m_transmissionColorDflt = RtColorRGB(0.f);
    m_transmissionBehaviorDflt = k_transmissiveScatter;
}

AtomoOcclusionFactory::~AtomoOcclusionFactory()
{
}

// Init
//  should be called once per RIB-instance. We look for parameter name
//  errors, and "cache" an understanding of our graph-evaluation requirements
//  in the form of allocation sizes.
int
AtomoOcclusionFactory::Init(RixContext &ctx, char const *pluginpath)
{
    return 0;
}

// Synchronize: delivers occasional status information
// from the renderer. Parameterlist contents depend upon the SyncMsg.
// This method is optional and the default implementation ignores all
// events.
void
AtomoOcclusionFactory::Synchronize(RixContext &ctx, RixSCSyncMsg syncMsg,
                              RixParameterList const *parameterList)
{
    if (syncMsg == k_RixSCRenderBegin)
    {
        s_reflDiffuseLobe = RixBXLookupLobeByName(ctx, false, false, true, false,
                                                  k_reflDiffuseLobeId,
                                                  "Diffuse");
        s_tranDiffuseLobe = RixBXLookupLobeByName(ctx, false, false, false, false,
                                                  k_tranDiffuseLobeId,
                                                  "Diffuse");
        s_albedoLobe = RixBXLookupLobeByName(ctx, false, false, false, true,
                                             k_albedoLobeId,
                                             "Albedo");

        s_reflDiffuseLobeTraits = RixBXLobeTraits(s_reflDiffuseLobe);
        s_tranDiffuseLobeTraits = RixBXLobeTraits(s_tranDiffuseLobe);
        s_albedoLobeTraits = RixBXLobeTraits(s_albedoLobe);
     }
}

enum paramIds
{
    k_diffuseColor,
    k_transmissionBehavior,
    k_transmissionColor,
    k_presence,
    k_bumpNormal,
    k_numParams
};

RixSCParamInfo const *
AtomoOcclusionFactory::GetParamTable()
{
    // see .args file for comments, etc...
    static RixSCParamInfo s_ptable[] =
    {
        RixSCParamInfo("diffuseColor", k_RixSCColor),
        RixSCParamInfo("transmissionBehavior", k_RixSCInteger), // uniform
        RixSCParamInfo("transmissionColor", k_RixSCColor),
        RixSCParamInfo("presence", k_RixSCFloat),
        RixSCParamInfo("bumpNormal", k_RixSCNormal),

        RixSCParamInfo() // end of table
    };
    return &s_ptable[0];
}

// CreateInstanceData:
//    analyze plist to determine our response to GetOpacityHints.
//    Checks these inputs:
//          transmissionBehavior (value),
//          presence (networked)
int
AtomoOcclusionFactory::CreateInstanceData(RixContext &ctx,
                                      char const *handle,
                                      RixParameterList const *plist,
                                      InstanceData *idata)
{
    RtUInt64 req = k_TriviallyOpaque;
    RixSCConnectionInfo cnx1, cnx2;
    RixSCType typ;
    plist->GetParamInfo(k_transmissionBehavior, &typ, &cnx1);
    plist->GetParamInfo(k_transmissionColor, &typ, &cnx2);
    if(cnx1 == k_RixSCParameterListValue && cnx2 != k_RixSCDefaultValue)
    {
        // we have a non-default value for transmissionBehavior
        // and transmissionColor, let's check the requested behavior
        RtInt ival;
        if(k_RixSCUniform==plist->EvalParam(k_transmissionBehavior, -1, &ival))
        {
            switch((TransmissionBehavior) ival)
            {
            case k_ignoreTransmission:
            case k_transmissiveScatter:
                // no opacity requirements
                break;
            case k_transmissiveShadows:
            case k_transmissiveScatterAndShadows:
                req |= (k_ComputesOpacity | k_OpacityCanBeCached);
                break;
            default:
                {
                    RixMessages *m = (RixMessages *)
                        ctx.GetRixInterface(k_RixMessages);
                        m->Warning("AtomoOcclusion bad transmissionBehavior %d\n",
                                    ival);
                }
                break;
            }
        }

    }

    plist->GetParamInfo(k_presence, &typ, &cnx1);
    if(cnx1 == k_RixSCNetworkValue)
    {
        req |= k_ComputesPresence | k_PresenceCanBeCached;
    }

    idata->data = (void *) req; // no memory allocated, overload pointer
    idata->freefunc = NULL;
    return 0;
}

int
AtomoOcclusionFactory::GetInstanceHints(RtConstPointer instanceData) const
{
    // our instance data is the RixBxdfFactory::InstanceHints bitfield.
    InstanceHints const &hints = (InstanceHints const&) instanceData;
    return hints;
}

// Finalize:
//  companion to Init, called with the expectation that any data
//  allocated there will be released here.
void
AtomoOcclusionFactory::Finalize(RixContext &)
{
}

RixBsdf *
AtomoOcclusionFactory::BeginScatter(RixShadingContext const *sCtx,
                                RixBXLobeTraits const &lobesWanted,
                                RixSCShadingMode sm,
                                RtConstPointer instanceData)
{
    // Get all input data
    RtColorRGB const * diff;
    RtColorRGB const * trans = NULL;
    RtNormal3 const * bumpNormal = NULL;
    sCtx->EvalParam(k_diffuseColor, -1, &diff, &m_diffuseColorDflt, true);

    RtInt const *transBehavior=NULL;
    sCtx->EvalParam(k_transmissionBehavior, -1,
                    &transBehavior, &m_transmissionBehaviorDflt,
                    false/*don't promote*/);
    switch(transBehavior[0]) // we're asserting uniform for the behavior
    {
    case k_transmissiveScatter:
    case k_transmissiveScatterAndShadows:
        {
            // we're scattering, but it's possible that transmission color
            // is uniform 0 - meaning no translucency. If the detail is
            // varying, we assume something interesting is going on.
            // If its uniform, w promote a non-zero value to varying for
            // code simplicity.
            RixSCDetail d = sCtx->EvalParam(k_transmissionColor, -1, &trans,
                                            &m_transmissionColorDflt, false);
            if(d == k_RixSCUniform)
            {
                if(trans[0].ChannelMax() == 0.0f)
                    trans = 0L; // no translucency
                else
                {
                    sCtx->EvalParam(k_transmissionColor, -1, &trans,
                                    &m_transmissionColorDflt, true);
                }
            }

        }
        break;
    default:
        // no translucency for scatter (trans == NULL)
        break;
    }

    if(k_RixSCVarying != sCtx->EvalParam(k_bumpNormal, -1, &bumpNormal))
        bumpNormal = NULL;

    RixShadingContext::Allocator pool(sCtx);
    void *mem = pool.AllocForBxdf<AtomoOcclusion>(1);

    // Must use placement new to set up the vtable properly
    AtomoOcclusion *eval = new (mem) AtomoOcclusion(sCtx, this, lobesWanted,
                                            diff, trans, bumpNormal);

    return eval;
}

void
AtomoOcclusionFactory::EndScatter(RixBsdf *)
{
}

// We return a non-null RixOpacity when it appears that we need
// one as (currently) defined by:
//     presence is connected |
//     transmissionMode is one of:
//          k_transmissiveShadows, k_transmissiveScatterAndShadows
//     transmission is connected or non-default
//
RixOpacity *
AtomoOcclusionFactory::BeginOpacity(RixShadingContext const *sCtx,
                                RixSCShadingMode shadingMode,
                                RtConstPointer instancedata)
{
    RixOpacity *result = NULL;
    RtFloat const *presence = NULL;
    RtColorRGB const *transmissionColor = NULL;
    RixSCDetail d1 = sCtx->EvalParam(k_presence, -1, &presence,
                                    &m_presenceDflt,
                                    false /*don't promote to varying*/);
    if(d1 != k_RixSCVarying)
        presence = NULL; // unless presence is varying, it's not interesting

    if(shadingMode != k_RixSCPresenceQuery)
    {
        RixSCConnectionInfo cinfo;
        RixSCType typ;
        sCtx->GetParamInfo(k_transmissionColor, &typ, &cinfo);
        if(cinfo != k_RixSCDefaultValue)
        {
            // transmission color isn't black (black means opaque)
            // so let's look at the behavior
            RtInt const *transBehavior=NULL;
            sCtx->EvalParam(k_transmissionBehavior, -1,
                            &transBehavior, &m_transmissionBehaviorDflt,
                            false/*don't promote*/);
            switch(transBehavior[0])
            {
            case k_transmissiveShadows:
            case k_transmissiveScatterAndShadows:
                // this is the case where we care about transmission
                // for opacity-related activities.
                sCtx->EvalParam(k_transmissionColor, -1,
                                &transmissionColor,
                                &m_transmissionColorDflt,
                                true /*promote to varying*/);
                break;
            default:
                transmissionColor = NULL; // ignore our value
                break;
            }
        }
    }
    if(presence || transmissionColor)
    {
        RixShadingContext::Allocator pool(sCtx);
        void *mem = pool.AllocForBxdf<PxrSurfaceOpacity>(1);
        result = new (mem) PxrSurfaceOpacity(sCtx, this,
                                            presence, transmissionColor);
    }
    return result;
}

void
AtomoOcclusionFactory::EndOpacity(RixOpacity *)
{
}
